* Chapitre 1 : Généralités
+ Des bouts de trucs pour la programmation système dans 3 modules :
  - Unix,
  - Env,
  - Stdlib

+ Attention : le module Unix redéfini des identificateurs de Stdlib
  (exemple Stdlib.stdin/Unix.stdin)

+ Interface avec le programme appelant
-> pas de le programme, mais utile ?
Sys.argv


+ page 8 :
   - Stdlib.exit : call functions defines with [at_exit] (déplier en sens inverse)
     -> 0 = tout va bien
     -> <> 0 : pas bon
     -> 2 : erreur non levée
   - Unix._exit : comme exit mais sans appeler les fonctions de [at_exit], no  flush etc..
     -> utiliser pour Unix.fork

+ page 9 :  Erreur dans le module Unix -> exception Unix_error of error * string * string
type error = E2BIG | EACCES | EAGAIN | ... | EUNKNOWNERR of int
argument 2 : nom de l'appel système qui a déclenché l'erreur
argument 3 : objet sur lequel l'erreur s'est produit (fd par exemple)

handle_unix_error

* Chapitre 2 : le système de fichiers
module Filename

** Explication
Implémentation interne : blocs et nœuds d’index (inode).

*** 1
Dag implémentée dans des noeuds (disque découper en bloc)
-> nombre d'inode maximal car la table des noeuds à une taille max
(pas lié à l'espace disque)
df -i

On présente le partage de blocs (avec liens physiques ou symbo-
liques) et l’organisation hiérarchique de l’espace de nommage.

liens physiques/symboliques -> ln en unix pour créer avoir le fichier
en plusieurs

*** 2
Accès, droit et attributs

*** 3
tube -> se programme
à l'ouverture fichier spécial = pipe (pour être passer à un autre prog)
mais se manipule comme n'importe quel fichier

accès spécial (écrit d'un coté, lit de l'autre)

plusieurs facons de faire un pipe :
quand tu lances un autre programme, tu peux remplacer ses fichiers spéciaux (stdin)

en unix, l'appel de programme = un fork suivant d'un exec
** Note
C'est un DAG
*** Lien symbolique
s lien symbolique contenant le chemin l alors p/s/q désigne
+ l/q si l est un lien absolu ou
+ p/l/q sinon
*** Noms de fichiers, descripteurs de fichiers
descripteur de fichier :
- pointeur vers un fichier
- position courante de lecture / écriture
- permission
- drapeau sur le comportement des lectures et des écritures (ex : écritures en écrasement)

3 fd sont alloués au lancement d'un programme :
- stdin. Peut être changé par <
- stdout. Peut être changé par >
- stderr. Peut être changé par 2>

Info sur le noeud d'index : avec stat/lstat/fstat

Permission : file_perm qui est une abbréviation pour le type int

*** Ouverture d'un fichier
Lien entre les fonctions Unix et les fonctions de la  Stdlib
* Plan

** Partie système
Attention : rappeler l'obj général : couvrir Unix autour d'un cas concret

-> guidé par un exemple minishell

-> présenter un AST final / liste de commande de ce qu'on veut
   supporter pour notre minishell (notre objectif)

-> Plan  :
  - programmer les commandes (sans fork) :
    + manipulation de fichiers
    + current_working_directory
    + > < 2> avec dup2

  - introduction du modèle des processus dans Unix :
    + un peu de théorie bas niveau (2-3 slides)
    + le | avec fork
    + finir l'exemple avec le parser et surtout la boucle principale

  - interlude réseau (commande ping/echo)
    + intro sur les sockets
    + netcat

  - en vrai, on utilise plutôt Lwt.Unix / Lwt.IO, Bos ETC
    + pour simplifier l'API d'unix
    + ou ajouter une couche d'asynchrone
      -> un exemple concret avec une implementation de cp avec lwt et comparaison des perfs

  -> Ouverture sur Mirage

** Ocaml dans la vraie vie (30-40 min)
  - (~5-10min) Mirage : un système en Ocaml

  - (~3-5min) Ocaml 5.0.0 (donner des exemples avec les algos enseignées Peterson et Lamport)

  - (~15-20min) QCheck -> trouver des exemples interessant

  - (~5-10min) Environnement : ocamlformat, codespaces...
